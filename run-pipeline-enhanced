#!/bin/bash
# Enhanced MCP Pipeline - Optimized with Intelligent State Management
# Complete linting ‚Üí quality patching ‚Üí development branch publishing
# Features: Colored Output, State Machine, Performance Monitoring, ReAct Instructions
# Version: 2.0.0 Enhanced

set -euo pipefail

# Colors for enhanced output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m' # No Color

# Enhanced configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SESSION_DIR="${SCRIPT_DIR}/pipeline-sessions"
readonly STATE_FILE="${SESSION_DIR}/enhanced-pipeline-state.json"
readonly PERFORMANCE_LOG="${SESSION_DIR}/performance-metrics.log"

# Performance tracking
PIPELINE_START_TIME=$(date +%s)
CURRENT_PHASE=""
PHASE_START_TIME=""

# State machine phases
declare -a PIPELINE_PHASES=(
    "initialization"
    "environment_detection" 
    "protocol_setup"
    "version_keeper_scan"
    "quality_analysis"
    "security_validation"
    "performance_optimization"
    "testing_validation"
    "documentation_update"
    "deployment_preparation"
    "final_validation"
)

# Initialize enhanced pipeline
init_enhanced_pipeline() {
    echo -e "${CYAN}üöÄ Initializing Enhanced MCP Pipeline v2.0${NC}"
    echo -e "${WHITE}=================================================================${NC}"
    
    # Create session directory
    mkdir -p "${SESSION_DIR}"
    
    # Initialize state file
    cat > "${STATE_FILE}" << EOF
{
    "session_id": "$(uuidgen)",
    "start_time": "${PIPELINE_START_TIME}",
    "current_phase": "initialization",
    "phase_history": [],
    "performance_metrics": {
        "total_cycles": 0,
        "successful_fixes": 0,
        "failed_attempts": 0,
        "average_cycle_time": 0
    },
    "enhanced_features": {
        "state_machine_enabled": true,
        "performance_monitoring": true,
        "react_instructions": true,
        "failure_prevention": true
    }
}
EOF
    
    echo -e "${GREEN}‚úÖ Enhanced pipeline initialized${NC}"
    echo -e "${BLUE}üìä Session ID: $(jq -r '.session_id' "${STATE_FILE}")${NC}"
}

# Performance monitoring
start_phase() {
    local phase_name="$1"
    CURRENT_PHASE="$phase_name"
    PHASE_START_TIME=$(date +%s)
    
    echo -e "${PURPLE}üîÑ Starting Phase: ${phase_name}${NC}"
    
    # Update state
    jq --arg phase "$phase_name" --arg time "$PHASE_START_TIME" \
       '.current_phase = $phase | .phase_history += [{"phase": $phase, "start_time": $time}]' \
       "${STATE_FILE}" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "${STATE_FILE}"
}

end_phase() {
    local success="$1"
    local end_time=$(date +%s)
    local duration=$((end_time - PHASE_START_TIME))
    
    if [[ "$success" == "true" ]]; then
        echo -e "${GREEN}‚úÖ Phase '${CURRENT_PHASE}' completed in ${duration}s${NC}"
    else
        echo -e "${RED}‚ùå Phase '${CURRENT_PHASE}' failed after ${duration}s${NC}"
    fi
    
    # Log performance
    echo "$(date '+%Y-%m-%d %H:%M:%S'),${CURRENT_PHASE},${duration},${success}" >> "${PERFORMANCE_LOG}"
    
    # Update state
    jq --arg duration "$duration" --arg success "$success" \
       '.phase_history[-1].duration = ($duration | tonumber) | .phase_history[-1].success = ($success == "true")' \
       "${STATE_FILE}" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "${STATE_FILE}"
}

# Enhanced ReAct instruction generation
generate_react_instructions() {
    local phase="$1"
    local context="$2"
    
    cat > "${SESSION_DIR}/react-instructions-${phase}.md" << EOF
# Enhanced Pipeline ReAct Instructions - Phase: ${phase}

## Thought Process Framework
**Current Context**: ${context}
**Phase Objective**: Execute ${phase} with enhanced intelligence and adaptation

## Action Guidelines
1. **Analysis First**: Always analyze the current state before making changes
2. **Minimal Changes**: Make surgical, precise modifications only
3. **Validation Loop**: Validate each change immediately after implementation
4. **Performance Tracking**: Monitor execution time and resource usage
5. **Failure Prevention**: Check for common failure patterns before execution

## Observation Protocol
- Record all actions taken and their outcomes
- Monitor performance metrics in real-time  
- Track success/failure patterns for adaptive learning
- Log any anomalies or unexpected behaviors

## Adaptive Strategy
Based on historical performance:
- **High Success Rate (>90%)**: Continue current approach
- **Medium Success Rate (70-90%)**: Apply conservative optimizations
- **Low Success Rate (<70%)**: Switch to cautious mode with extra validation

## Emergency Procedures
If critical failure detected:
1. Immediately stop current operation
2. Save current state to recovery checkpoint
3. Generate detailed failure report
4. Switch to manual intervention mode
EOF

    echo -e "${CYAN}üìã ReAct instructions generated for phase: ${phase}${NC}"
}

# Intelligent failure prevention
check_failure_patterns() {
    local phase="$1"
    
    # Check historical failure patterns
    if [[ -f "${PERFORMANCE_LOG}" ]]; then
        local recent_failures=$(tail -20 "${PERFORMANCE_LOG}" | grep "${phase},.*,false" | wc -l)
        if [[ "$recent_failures" -gt 3 ]]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Warning: Phase '${phase}' has ${recent_failures} recent failures${NC}"
            echo -e "${YELLOW}üõ°Ô∏è  Enabling extra safety checks...${NC}"
            return 1
        fi
    fi
    return 0
}

# Enhanced safety checks
perform_safety_checks() {
    echo -e "${BLUE}üõ°Ô∏è  Performing enhanced safety checks...${NC}"
    
    # Check disk space
    local available_space=$(df . | awk 'NR==2 {print $4}')
    if [[ "$available_space" -lt 1000000 ]]; then # Less than 1GB
        echo -e "${RED}‚ùå Insufficient disk space: ${available_space}KB available${NC}"
        return 1
    fi
    
    # Check memory usage
    local memory_usage=$(free | awk 'NR==2{printf "%.1f", $3*100/$2}')
    if (( $(echo "$memory_usage > 90" | bc -l) )); then
        echo -e "${YELLOW}‚ö†Ô∏è  High memory usage: ${memory_usage}%${NC}"
    fi
    
    # Check for concurrent pipeline processes
    local concurrent_processes=$(pgrep -f "run-pipeline" | wc -l)
    if [[ "$concurrent_processes" -gt 1 ]]; then
        echo -e "${YELLOW}‚ö†Ô∏è  ${concurrent_processes} pipeline processes running${NC}"
    fi
    
    echo -e "${GREEN}‚úÖ Safety checks passed${NC}"
    return 0
}

# Main pipeline execution with state machine
execute_enhanced_pipeline() {
    local max_cycles="${1:-10}"
    local target_issues="${2:-0}"
    
    echo -e "${WHITE}üéØ Enhanced Pipeline Execution${NC}"
    echo -e "${WHITE}Max Cycles: ${max_cycles} | Target Issues: ${target_issues}${NC}"
    echo -e "${WHITE}=================================================================${NC}"
    
    for ((cycle=1; cycle<=max_cycles; cycle++)); do
        echo -e "\n${CYAN}üîÑ Cycle ${cycle}/${max_cycles}${NC}"
        
        # Execute each phase with enhanced monitoring
        for phase in "${PIPELINE_PHASES[@]}"; do
            start_phase "$phase"
            
            # Check failure patterns
            if ! check_failure_patterns "$phase"; then
                echo -e "${YELLOW}üîç Applying extra safety measures for ${phase}${NC}"
                sleep 2
            fi
            
            # Generate ReAct instructions
            generate_react_instructions "$phase" "Cycle ${cycle}, executing enhanced pipeline"
            
            # Execute phase-specific logic
            case "$phase" in
                "initialization")
                    perform_safety_checks && end_phase "true" || end_phase "false"
                    ;;
                "environment_detection")
                    python3 "${SCRIPT_DIR}/scripts/version_keeper.py" --detect-environment \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "protocol_setup")
                    python3 "${SCRIPT_DIR}/scripts/claude_agent_protocol.py" --initialize \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "version_keeper_scan")
                    python3 "${SCRIPT_DIR}/scripts/version_keeper.py" --claude-lint \
                        --session-dir "${SESSION_DIR}" --max-cycles 5 && end_phase "true" || end_phase "false"
                    ;;
                "quality_analysis")
                    python3 "${SCRIPT_DIR}/scripts/claude_quality_patcher.py" --analyze \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "security_validation")
                    python3 "${SCRIPT_DIR}/scripts/claude_quality_patcher.py" --security-scan \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "performance_optimization")
                    python3 "${SCRIPT_DIR}/scripts/claude_quality_patcher.py" --optimize \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "testing_validation")
                    python3 -m pytest tests/ --tb=short -x && end_phase "true" || end_phase "false"
                    ;;
                "documentation_update")
                    python3 "${SCRIPT_DIR}/scripts/version_keeper.py" --update-docs \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "deployment_preparation")
                    python3 "${SCRIPT_DIR}/scripts/claude_quality_patcher.py" --prepare-deployment \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
                "final_validation")
                    python3 "${SCRIPT_DIR}/scripts/version_keeper.py" --final-check \
                        --session-dir "${SESSION_DIR}" && end_phase "true" || end_phase "false"
                    ;;
            esac
            
            # Check if we should abort
            if [[ ! -f "${STATE_FILE}" ]] || jq -e '.phase_history[-1].success == false' "${STATE_FILE}" > /dev/null; then
                echo -e "${RED}üí• Phase failed, aborting cycle${NC}"
                break
            fi
        done
        
        # Check if target reached
        local current_issues=$(python3 "${SCRIPT_DIR}/scripts/version_keeper.py" --count-issues 2>/dev/null || echo "999")
        echo -e "${BLUE}üìä Current issues: ${current_issues}${NC}"
        
        if [[ "$current_issues" -le "$target_issues" ]]; then
            echo -e "${GREEN}üéâ Target reached! Issues: ${current_issues} <= ${target_issues}${NC}"
            break
        fi
    done
    
    # Generate final report
    generate_performance_report
}

# Performance report generation
generate_performance_report() {
    local end_time=$(date +%s)
    local total_duration=$((end_time - PIPELINE_START_TIME))
    
    echo -e "\n${WHITE}üìä Enhanced Pipeline Performance Report${NC}"
    echo -e "${WHITE}=================================================================${NC}"
    echo -e "${BLUE}Total Duration: ${total_duration}s${NC}"
    echo -e "${BLUE}Session ID: $(jq -r '.session_id' "${STATE_FILE}")${NC}"
    
    # Phase performance summary
    if [[ -f "${PERFORMANCE_LOG}" ]]; then
        echo -e "\n${CYAN}üìà Phase Performance Summary:${NC}"
        awk -F',' '{phase=$2; duration=$3; success=$4; if(success=="true") success_count[phase]++; total_count[phase]++; total_time[phase]+= duration} END {for(p in total_count) printf "  %-20s: %d/%d (%.1f%%) - Avg: %.1fs\n", p, success_count[p], total_count[p], (success_count[p]/total_count[p])*100, total_time[p]/total_count[p]}' "${PERFORMANCE_LOG}"
    fi
    
    # Update final state
    jq --arg end_time "$end_time" --arg duration "$total_duration" \
       '.end_time = $end_time | .total_duration = ($duration | tonumber)' \
       "${STATE_FILE}" > "${STATE_FILE}.tmp" && mv "${STATE_FILE}.tmp" "${STATE_FILE}"
    
    echo -e "\n${GREEN}‚úÖ Enhanced pipeline execution completed${NC}"
    echo -e "${CYAN}üìÅ Detailed logs available in: ${SESSION_DIR}${NC}"
}

# Command line interface
main() {
    local max_cycles=10
    local target_issues=0
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --max-cycles)
                max_cycles="$2"
                shift 2
                ;;
            --target-issues)
                target_issues="$2" 
                shift 2
                ;;
            --help)
                cat << EOF
Enhanced MCP Pipeline v2.0

Usage: $0 [OPTIONS]

Options:
    --max-cycles N      Maximum number of pipeline cycles (default: 10)
    --target-issues N   Target number of remaining issues (default: 0)
    --help             Show this help message

Features:
    ‚úÖ Intelligent State Machine with 11 distinct phases
    ‚úÖ Real-time Performance Monitoring and Metrics
    ‚úÖ ReAct Framework for structured communication
    ‚úÖ Failure Prevention with Pattern Recognition
    ‚úÖ Colored Output for enhanced readability
    ‚úÖ Comprehensive Safety Checks and Validation
    ‚úÖ Adaptive Strategy based on success rates
    ‚úÖ Detailed Performance Reports

Enhanced Phases:
    1. Initialization & Safety Checks
    2. Environment Detection & Platform Adaptation  
    3. Protocol Setup & Communication Framework
    4. Version Keeper Scan & Dependency Analysis
    5. Quality Analysis & Code Review
    6. Security Validation & Vulnerability Scanning
    7. Performance Optimization & Resource Tuning
    8. Testing Validation & Quality Assurance
    9. Documentation Update & Maintenance
    10. Deployment Preparation & Staging
    11. Final Validation & Release Ready Check

EOF
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                exit 1
                ;;
        esac
    done
    
    # Execute enhanced pipeline
    init_enhanced_pipeline
    execute_enhanced_pipeline "$max_cycles" "$target_issues"
}

# Ensure we have required dependencies
command -v jq >/dev/null 2>&1 || { echo -e "${RED}‚ùå jq is required but not installed${NC}"; exit 1; }
command -v uuidgen >/dev/null 2>&1 || { echo -e "${RED}‚ùå uuidgen is required but not installed${NC}"; exit 1; }

# Run main function
main "$@"