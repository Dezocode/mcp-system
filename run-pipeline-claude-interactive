#!/bin/bash
# MCP Claude Pipeline - Interactive Mode
# Designed for Claude Code interaction without API keys
# Exits immediately after generating instructions for Claude

SCRIPT_NAME="$(basename "$0")"
PIPELINE_VERSION="3.0.0-interactive"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Session management
SESSION_FILE="sessions/.mcp-pipeline-state.json"
INSTRUCTIONS_FILE="docs/.claude-instructions.md"
FIXES_FILE="sessions/.claude-fixes.json"

# ============================================================================
# STATE MANAGEMENT
# ============================================================================

get_current_state() {
    if [[ -f "$SESSION_FILE" ]]; then
        python3 -c "
import json
with open('$SESSION_FILE', 'r') as f:
    state = json.load(f)
    print(f\"{state.get('phase', 'INIT')}|{state.get('issues_count', -1)}|{state.get('cycle', 0)}|{state.get('last_run', '')}\")
" 2>/dev/null || echo "INIT|-1|0|"
    else
        echo "INIT|-1|0|"
    fi
}

save_state() {
    local phase=$1
    local issues=$2
    local cycle=$3
    
    python3 -c "
import json
from datetime import datetime

state = {
    'phase': '$phase',
    'issues_count': $issues,
    'cycle': $cycle,
    'last_run': datetime.now().isoformat(),
    'version': '$PIPELINE_VERSION'
}

with open('$SESSION_FILE', 'w') as f:
    json.dump(state, f, indent=2)
"
}

# ============================================================================
# PHASE EXECUTION
# ============================================================================

run_scan_phase() {
    echo -e "${CYAN}🔍 SCANNING FOR ISSUES...${NC}"
    
    # Create output dirs
    mkdir -p reports sessions
    
    # FORCE FRESH REPORT: Remove old reports to prevent reuse
    echo -e "${YELLOW}🗑️  Clearing old reports to ensure fresh scan...${NC}"
    rm -f reports/*lint*.json 2>/dev/null || true
    rm -f sessions/.claude-fixes.json 2>/dev/null || true
    
    # Generate timestamp for this scan
    local scan_timestamp=$(date +"%Y%m%d-%H%M%S")
    echo -e "${BLUE}⏰ Fresh scan timestamp: $scan_timestamp${NC}"
    
    # Run comprehensive lint with real issues only - ALWAYS FRESH
    # Direct flake8 implementation (bypassing broken version_keeper.py)
    echo -e "${BLUE}📊 Running flake8 scan...${NC}"
    
    # Run flake8 and capture output
    flake8 --exclude=.mcp-system-backups-disconnected,scripts/version_keeper.py \
           --statistics --count --format='%(path)s:%(row)d:%(col)d: %(code)s %(text)s' \
           . > sessions/.pipeline-scan-$scan_timestamp.log 2>&1 || true
    
    # Generate JSON report from flake8 output
    python3 -c "
import json
import re
import os
from datetime import datetime

report_file = 'reports/claude-lint-report-$scan_timestamp.json'
log_file = 'sessions/.pipeline-scan-$scan_timestamp.log'

issues = []
total_count = 0

if os.path.exists(log_file):
    with open(log_file, 'r') as f:
        content = f.read()
        
    # Parse flake8 output
    for line in content.split('\n'):
        # Match flake8 format: ./file:line:col: CODE message
        match = re.match(r'(.+):(\d+):(\d+): (\w+) (.+)', line.strip())
        if match:
            file_path, line_num, col_num, code, message = match.groups()
            issues.append({
                'file': file_path,
                'line': int(line_num),
                'column': int(col_num),
                'code': code,
                'message': message,
                'tool': 'flake8',
                'severity': 'error' if code.startswith('E') or code.startswith('F') else 'warning'
            })
    
    total_count = len(issues)
    
    # Generate fixes from issues for claude_quality_patcher.py
    def generate_fix_action(code, message, file_path, line_num):
        '''Generate appropriate fix action for different flake8 codes'''
        if code == 'W292':  # no newline at end of file
            return {'action': 'add_newline', 'location': 'end_of_file'}
        elif code == 'W291':  # trailing whitespace
            return {'action': 'remove_trailing_whitespace', 'line': line_num}
        elif code == 'W293':  # blank line contains whitespace
            return {'action': 'remove_whitespace_from_blank_line', 'line': line_num}
        elif code.startswith('E501'):  # line too long
            return {'action': 'break_long_line', 'line': line_num, 'max_length': 88}
        elif code.startswith('F401'):  # unused import
            return {'action': 'remove_unused_import', 'line': line_num}
        elif code.startswith('E722'):  # bare except
            return {'action': 'specify_exception_type', 'line': line_num}
        elif code.startswith('F541'):  # f-string missing placeholders
            return {'action': 'convert_fstring_to_string', 'line': line_num}
        else:
            return {'action': 'manual_review', 'line': line_num, 'reason': 'Complex fix required'}
    
    priority_fixes = []
    for issue in issues:
        # Convert flake8 issues to fix format
        fix = {
            'id': f'{issue[\"code\"]}_{issue[\"file\"]}_{issue[\"line\"]}',
            'file': issue['file'],
            'line': issue['line'],
            'column': issue['column'],
            'code': issue['code'],
            'message': issue['message'],
            'tool': 'flake8',
            'severity': issue['severity'],
            'type': 'auto-fix',
            'description': f'{issue[\"code\"]}: {issue[\"message\"]} at {issue[\"file\"]}:{issue[\"line\"]}',
            'fix_action': generate_fix_action(issue['code'], issue['message'], issue['file'], issue['line']),
            'confidence': 'high' if issue['code'] in ['W292', 'W291', 'W293', 'F401'] else 'medium'
        }
        priority_fixes.append(fix)
    
    # Generate report in expected format
    report_data = {
        'timestamp': datetime.now().isoformat(),
        'scan_id': 'pipeline-$scan_timestamp',
        'total_issues': total_count,
        'priority_fixes': priority_fixes,
        'validation_report': {
            'safe_recommendations': [f for f in priority_fixes if f['confidence'] == 'high'],
            'blocked_recommendations': [],
            'manual_review': [f for f in priority_fixes if f['confidence'] != 'high']
        },
        'quality_issues': {
            'flake8': {
                'passed': total_count == 0,
                'issues': issues,
                'count': total_count,
                'fixes': priority_fixes
            }
        },
        'summary': {
            'files_scanned': len(set(issue['file'] for issue in issues)),
            'total_violations': total_count,
            'total_fixes': len(priority_fixes)
        }
    }
    
    os.makedirs('reports', exist_ok=True)
    with open(report_file, 'w') as f:
        json.dump(report_data, f, indent=2)
    
    print(f'Generated report: {report_file}', file=__import__('sys').stderr)
" 2>&1 | tee -a sessions/.pipeline-scan-$scan_timestamp.log
    
    # Extract issues from the FRESHLY GENERATED report
    local issues=$(python3 -c "
import json
import glob
import os
import sys
from datetime import datetime, timedelta

try:
    # Find the latest lint report (claude-lint-report pattern)
    reports = glob.glob('reports/*lint*.json')
    if reports:
        # Get the newest report by creation time
        latest = max(reports, key=os.path.getctime)
        
        print(f'Using report: {latest}', file=sys.stderr)
        
        with open(latest, 'r') as f:
            data = json.load(f)
            total = data.get('total_issues', 0)
            # Save clean version for fixes with timestamp
            data['pipeline_scan_timestamp'] = '$scan_timestamp'
            data['report_freshness_verified'] = True
            with open('$FIXES_FILE', 'w') as out:
                json.dump(data, out, indent=2)
            print(total)
    else:
        print('No reports found', file=sys.stderr)
        print(0)
except Exception as e:
    print(f'Error processing report: {e}', file=sys.stderr)
    print(0)
" 2>/dev/null)
    
    echo -e "${GREEN}✅ Scan complete: Found $issues issues${NC}"
    
    # Return 0 if no issues, otherwise return 1 (not the count)
    # Ensure issues is a valid number
    if [[ "$issues" =~ ^[0-9]+$ ]]; then
        if [[ $issues -eq 0 ]]; then
            return 0
        else
            return 1
        fi
    else
        # Non-numeric value, assume there are issues
        echo -e "${RED}⚠️ Warning: Invalid issue count '$issues', assuming issues exist${NC}"
        return 1
    fi
}

run_fix_phase() {
    echo -e "${CYAN}🔧 GENERATING FIX INSTRUCTIONS...${NC}"
    
    # Generate fixes with quality patcher in claude-agent mode
    python3 scripts/claude_quality_patcher.py \
        --claude-agent \
        --max-fixes 10 \
        --batch-mode 2>&1 | tee .pipeline-fixes.log
    
    local fix_count=$(grep -c "File:" .pipeline-fixes.log 2>/dev/null || echo "0")
    echo -e "${GREEN}✅ Generated $fix_count fix instructions${NC}"
    return 0
}

run_validate_phase() {
    echo -e "${CYAN}✅ VALIDATING FIXES...${NC}"
    
    # FORCE FRESH VALIDATION: Clear any cached reports
    echo -e "${YELLOW}🔄 Clearing cached reports for fresh validation...${NC}"
    rm -f reports/*lint*.json 2>/dev/null || true
    
    # Generate fresh validation timestamp
    local validation_timestamp=$(date +"%Y%m%d-%H%M%S")
    echo -e "${BLUE}⏰ Fresh validation timestamp: $validation_timestamp${NC}"
    
    # Quick validation scan - ALWAYS FRESH
    python3 scripts/version_keeper.py \
        --comprehensive-lint \
        --lint-only \
        --real-issues-only \
        --quick-check \
        --output-dir reports/ \
        --session-id "validation-$validation_timestamp" 2>&1 | tail -10
    
    return 0
}

# ============================================================================
# CLAUDE INSTRUCTION GENERATION
# ============================================================================

generate_claude_instructions() {
    local phase=$1
    local issues=$2
    local cycle=$3
    
    cat > "$INSTRUCTIONS_FILE" << EOF
# 🤖 CLAUDE: AUTOMATED PIPELINE INSTRUCTIONS

## Current Status
- **Phase**: $phase
- **Issues Remaining**: $issues
- **Cycle**: $cycle
- **Time**: $(date)

## YOUR TASK

EOF

    case $phase in
        "SCAN_COMPLETE")
            cat >> "$INSTRUCTIONS_FILE" << 'EOF'
### 📋 APPLY FIXES

The pipeline has identified issues that need fixing. Follow these steps:

1. **Read the fixes file**:
   ```bash
   cat sessions/.claude-fixes.json
   ```

2. **Apply each fix using the appropriate tool**:
   - Use `Read` to examine files
   - Use `Edit` or `MultiEdit` to apply fixes
   - Focus on undefined functions, missing imports, and broken calls

3. **After applying ALL fixes, re-run the pipeline**:
   ```bash
   ./run-pipeline-claude-interactive
   ```

**IMPORTANT**: Apply ALL fixes before re-running the pipeline!

### Fix Details:
EOF
            # Append specific fixes
            if [[ -f "$FIXES_FILE" ]]; then
                python3 -c "
import json
try:
    with open('$FIXES_FILE', 'r') as f:
        data = json.load(f)
        quality_issues = data.get('quality_issues', {})
        count = 0
        for tool, tool_data in quality_issues.items():
            fixes = tool_data.get('fixes', [])
            for fix in fixes[:10]:  # Limit to 10 fixes per run
                count += 1
                file = fix.get('file', 'unknown')
                line = fix.get('line', 0)
                issue = fix.get('message', 'No description')
                print(f\"\n**Fix {count}**: {file}:{line}\")
                print(f\"  Issue: {issue}\")
                if 'suggestion' in fix:
                    print(f\"  Suggestion: {fix['suggestion']}\")
except Exception as e:
    print(f\"Error reading fixes: {e}\")
" >> "$INSTRUCTIONS_FILE"
            fi
            ;;
            
        "FIXES_APPLIED")
            cat >> "$INSTRUCTIONS_FILE" << 'EOF'
### ✅ VALIDATE FIXES

Fixes have been applied. Now validate them:

1. **Re-run the pipeline to check for remaining issues**:
   ```bash
   ./run-pipeline-claude-interactive
   ```

2. The pipeline will:
   - Scan for remaining issues
   - Report the new count
   - Generate new fix instructions if needed

**IMPORTANT**: Run the command above immediately!
EOF
            ;;
            
        "ALL_CLEAN")
            cat >> "$INSTRUCTIONS_FILE" << 'EOF'
### 🎉 SUCCESS!

All issues have been resolved! The codebase is now clean.

**Final Statistics**:
- Total cycles: $cycle
- All quality checks: PASSED
- Ready for: Production deployment

**Optional**: Create a git commit:
```bash
git add -A
git commit -m "fix: resolve all quality issues via automated pipeline"
```
EOF
            ;;
            
        "INIT"|*)
            cat >> "$INSTRUCTIONS_FILE" << 'EOF'
### 🚀 START PIPELINE

This is the first run. Start the scanning process:

```bash
./run-pipeline-claude-interactive
```

The pipeline will:
1. Scan your codebase for issues
2. Generate fix instructions
3. Exit for you to apply fixes
4. You re-run to validate

**Run the command above to begin!**
EOF
            ;;
    esac
    
    echo "" >> "$INSTRUCTIONS_FILE"
    echo "---" >> "$INSTRUCTIONS_FILE"
    echo "⏰ Generated at: $(date)" >> "$INSTRUCTIONS_FILE"
    echo "🔄 Pipeline version: $PIPELINE_VERSION" >> "$INSTRUCTIONS_FILE"
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}🚀 MCP CLAUDE PIPELINE - INTERACTIVE MODE v${PIPELINE_VERSION}${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    # Get current state
    IFS='|' read -r PHASE ISSUES CYCLE LAST_RUN <<< "$(get_current_state)"
    
    # Increment cycle
    CYCLE=$((CYCLE + 1))
    
    echo -e "${BLUE}📊 Session State:${NC}"
    echo "   Phase: $PHASE"
    echo "   Issues: $ISSUES"
    echo "   Cycle: $CYCLE"
    echo "   Last Run: $LAST_RUN"
    echo ""
    
    # State machine
    case $PHASE in
        "INIT"|"VALIDATE")
            # Run scan
            run_scan_phase
            SCAN_RESULT=$?
            
            # Get actual issue count from the FRESH fixes file
            ISSUES=$(python3 -c "
import json
import os
from datetime import datetime

try:
    if os.path.exists('$FIXES_FILE'):
        with open('$FIXES_FILE', 'r') as f:
            data = json.load(f)
            # Verify this is a fresh report
            if data.get('report_freshness_verified', False):
                scan_ts = data.get('pipeline_scan_timestamp', 'unknown')
                print(f'✅ Fresh scan ({scan_ts}): {data.get(\"total_issues\", 0)} issues', file=__import__('sys').stderr)
                print(data.get('total_issues', 0))
            else:
                print('⚠️ Stale report detected, treating as 0 issues', file=__import__('sys').stderr)
                print(0)
    else:
        print('❌ No fixes file found after scan', file=__import__('sys').stderr)
        print(0)
except Exception as e:
    print(f'❌ Error reading fixes: {e}', file=__import__('sys').stderr)
    print(0)
" 2>/dev/null || echo "0")
            
            if [[ $SCAN_RESULT -eq 0 ]] || [[ $ISSUES -eq 0 ]]; then
                echo -e "${GREEN}🎉 ALL CLEAN - No issues found!${NC}"
                save_state "ALL_CLEAN" 0 $CYCLE
                generate_claude_instructions "ALL_CLEAN" 0 $CYCLE
            else
                echo -e "${YELLOW}⚠️ Found $ISSUES issues - generating fixes${NC}"
                save_state "SCAN_COMPLETE" $ISSUES $CYCLE
                run_fix_phase
                generate_claude_instructions "SCAN_COMPLETE" $ISSUES $CYCLE
            fi
            ;;
            
        "SCAN_COMPLETE")
            # Assume fixes were applied, validate
            echo -e "${BLUE}📋 Assuming fixes were applied by Claude${NC}"
            run_validate_phase
            
            # FORCE FRESH RE-SCAN to check progress
            echo -e "${CYAN}🔄 Re-scanning with FRESH report generation...${NC}"
            run_scan_phase
            SCAN_RESULT=$?
            
            # Get actual issue count from FRESH report
            ISSUES=$(python3 -c "
import json
import os
from datetime import datetime

try:
    if os.path.exists('$FIXES_FILE'):
        with open('$FIXES_FILE', 'r') as f:
            data = json.load(f)
            # Verify report freshness
            if data.get('report_freshness_verified', False):
                print(f'✅ Using verified fresh report with {data.get(\"total_issues\", 0)} issues', file=__import__('sys').stderr)
                print(data.get('total_issues', 0))
            else:
                print('⚠️ Report freshness not verified, assuming 0 issues', file=__import__('sys').stderr)
                print(0)
    else:
        print('❌ No fixes file found', file=__import__('sys').stderr)
        print(0)
except Exception as e:
    print(f'❌ Error reading fixes: {e}', file=__import__('sys').stderr)
    print(0)
" 2>/dev/null || echo "0")
            
            if [[ $SCAN_RESULT -eq 0 ]] || [[ $ISSUES -eq 0 ]]; then
                echo -e "${GREEN}🎉 ALL ISSUES RESOLVED! (Fresh scan confirmed)${NC}"
                save_state "ALL_CLEAN" 0 $CYCLE
                generate_claude_instructions "ALL_CLEAN" 0 $CYCLE
            else
                echo -e "${YELLOW}⚠️ Still $ISSUES issues remaining (fresh scan)${NC}"
                save_state "SCAN_COMPLETE" $ISSUES $CYCLE
                run_fix_phase
                generate_claude_instructions "SCAN_COMPLETE" $ISSUES $CYCLE
            fi
            ;;
            
        "ALL_CLEAN")
            echo -e "${GREEN}✅ Pipeline already complete - all issues resolved!${NC}"
            echo ""
            echo "To reset and run again:"
            echo "  rm $SESSION_FILE"
            echo "  ./run-pipeline-claude-interactive"
            echo ""
            echo "To force fresh scan (ignoring cache):"
            echo "  rm -f reports/*lint*.json sessions/.claude-fixes.json"
            echo "  ./run-pipeline-claude-interactive"
            ;;
            
        *)
            echo -e "${RED}❌ Unknown state: $PHASE${NC}"
            echo "Resetting..."
            rm -f "$SESSION_FILE"
            save_state "INIT" -1 0
            generate_claude_instructions "INIT" -1 0
            ;;
    esac
    
    # Display instructions
    echo ""
    echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${MAGENTA}📋 CLAUDE INSTRUCTIONS${NC}"
    echo -e "${MAGENTA}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # Display the instructions file
    if [[ -f "$INSTRUCTIONS_FILE" ]]; then
        cat "$INSTRUCTIONS_FILE"
    else
        echo "No instructions generated. Check logs for errors."
    fi
    
    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YELLOW}⚡ PIPELINE EXITING - Follow instructions above!${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # Exit immediately - no waiting!
    exit 0
}

# Run immediately and exit
main "$@"